#include "AD9910V1.h"

uchar cfr1[] = {0x00, 0x00, 0x00, 0x00};						  //cfr1控制字，从右到左，从低位到高  打开OSK外部
uchar cfr2[] = {0x01, 0x00, 0x00, 0x00};						  //cfr2控制�??
uchar cfr3[] = {0x05, 0x3D, 0x41, 0x32};						  //cfr3控制�??  40M输入  25倍频  VC0=101   ICP=111;
uchar profile11[] = {0x3f, 0xff, 0x00, 0x00, 0x25, 0x09, 0x7b, 0x42}; //profile1控制�?? 0x25,0x09,0x7b,0x42
																	  //01振幅控制 23相位控制 4567频率调谐�??

uchar ramprofile0[8] = {0x00};                                     //ramprofile0控制�??
uchar drgparameter[20]={0x00};

//�??14位幅度控�??
const unsigned char ramdata_Square[4096] = {
//方波
0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00,
0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00,
0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00,
0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00, 0xff,0xfc,0x00,0x00,

0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,


};

//�??14位幅度控�??
const unsigned char ramdata_Sawtooth[4096] = {
//锯齿�??
0x00,0x00,0x00,0x00, 0x03,0xfc,0x00,0x00, 0x07,0xf8,0x00,0x00, 0x0b,0xf4,0x00,0x00, 0x0f,0xf0,0x00,0x00, 0x13,0xec,0x00,0x00, 0x17,0xe8,0x00,0x00, 0x1b,0xe4,0x00,0x00,
0x1f,0xe0,0x00,0x00, 0x23,0xdc,0x00,0x00, 0x27,0xd8,0x00,0x00, 0x2b,0xd4,0x00,0x00, 0x2f,0xd0,0x00,0x00, 0x33,0xcc,0x00,0x00, 0x37,0xc8,0x00,0x00, 0x3b,0xc4,0x00,0x00,
0x3f,0xc0,0x00,0x00, 0x43,0xbc,0x00,0x00, 0x47,0xb8,0x00,0x00, 0x4b,0xb4,0x00,0x00, 0x4f,0xb0,0x00,0x00, 0x53,0xac,0x00,0x00, 0x57,0xa8,0x00,0x00, 0x5b,0xa4,0x00,0x00,
0x5f,0xa0,0x00,0x00, 0x63,0x9c,0x00,0x00, 0x67,0x98,0x00,0x00, 0x6b,0x94,0x00,0x00, 0x6f,0x90,0x00,0x00, 0x73,0x8c,0x00,0x00, 0x77,0x88,0x00,0x00, 0x7b,0x84,0x00,0x00,

0x7f,0x80,0x00,0x00, 0x83,0x7c,0x00,0x00, 0x87,0x78,0x00,0x00, 0x8b,0x74,0x00,0x00, 0x8f,0x70,0x00,0x00, 0x93,0x6c,0x00,0x00, 0x97,0x68,0x00,0x00, 0x9b,0x64,0x00,0x00,
0x9f,0x60,0x00,0x00, 0xa3,0x5c,0x00,0x00, 0xa7,0x58,0x00,0x00, 0xab,0x54,0x00,0x00, 0xaf,0x50,0x00,0x00, 0xb3,0x4c,0x00,0x00, 0xb7,0x48,0x00,0x00, 0xbb,0x44,0x00,0x00,
0xbf,0x40,0x00,0x00, 0xc3,0x3c,0x00,0x00, 0xc7,0x38,0x00,0x00, 0xcb,0x34,0x00,0x00, 0xcf,0x30,0x00,0x00, 0xd3,0x2c,0x00,0x00, 0xd7,0x28,0x00,0x00, 0xdb,0x24,0x00,0x00,
0xdf,0x20,0x00,0x00, 0xe3,0x1c,0x00,0x00, 0xe7,0x18,0x00,0x00, 0xeb,0x14,0x00,0x00, 0xef,0x10,0x00,0x00, 0xf3,0x0c,0x00,0x00, 0xf7,0x08,0x00,0x00, 0xfb,0x04,0x00,0x00,


};
void AD9110_IOInit(void)
{
	PS_GPIO_SetMode(AD9910_PWR,	 OUTPUT, 0);
	PS_GPIO_SetMode(DROVER,		 INPUT,  0);
	PS_GPIO_SetMode(DRCTL,		 OUTPUT, 0);
	PS_GPIO_SetMode(DRHOLD, 	 OUTPUT, 0);
	PS_GPIO_SetMode(UP_DAT,		 OUTPUT, 0);
	PS_GPIO_SetMode(MAS_REST, 	 OUTPUT, 0);
	//PS_GPIO_SetMode(AD9910_IO_RESET,	OUTPUT, 0);
	PS_GPIO_SetMode(OSK,		 OUTPUT, 0);
	PS_GPIO_SetMode(PROFILE0,	 OUTPUT, 0);
	PS_GPIO_SetMode(PROFILE1,	 OUTPUT, 0);
	PS_GPIO_SetMode(PROFILE2,  	 OUTPUT, 0);
	PS_GPIO_SetMode(RSO,		 INPUT,  0);
	PS_GPIO_SetMode(CS,      	 OUTPUT, 0);
	PS_GPIO_SetMode(AD9910_SDIO, OUTPUT, 0);
	PS_GPIO_SetMode(SCLK,      	 OUTPUT, 0);
}

//=====================================================================

//======================閸欐垿锟�????8娴ｅ秵鏆熼幑顔锯柤鎼�????===================================
void txd_8bit(uchar txdat)
{
	uchar i, sbt;
	sbt = 0x80;
	PS_GPIO_SetPort(SCLK, 0);
	for (i = 0; i < 8; i++)
	{
		if ((txdat & sbt) == 0)
		PS_GPIO_SetPort(AD9910_SDIO, 0);
		else
		PS_GPIO_SetPort(AD9910_SDIO, 1);
		PS_GPIO_SetPort(SCLK, 1);
		sbt = sbt >> 1;
		PS_GPIO_SetPort(SCLK, 0);
	}
}

//======================ad9910閸掓繂顫愰崠鏍柤鎼�????================================
void Init_ad9910(void)
{
	PS_GPIO_Init(); //IO口初始化
	AD9110_IOInit(); //AD9910 IO控制口初始化
	
	PS_GPIO_SetPort(AD9910_PWR, 0); //AD9910 PWR引脚使能

	AD9910_Profile_Set(0);
	//PS_GPIO_SetPort(PROFILE0, 0); //通过三引脚选择初始化寄存器
	//PS_GPIO_SetPort(PROFILE1, 0);
	//PS_GPIO_SetPort(PROFILE2, 0);

	PS_GPIO_SetPort(DRCTL, 0);
	PS_GPIO_SetPort(DRHOLD, 0);
	PS_GPIO_SetPort(MAS_REST, 1);

	usleep(5000);

	PS_GPIO_SetPort(MAS_REST, 0);
}

//======================8位传�?====================================
void Txcfr(void)
{
	uchar k, m;
	
	PS_GPIO_SetPort(CS, 0);
	txd_8bit(0x00); //CRF1寄存�?1
	for (m = 0; m < 4; m++)
		txd_8bit(cfr1[m]);
	PS_GPIO_SetPort(CS, 1);
	for (k = 0; k < 10; k++)
		;

	PS_GPIO_SetPort(CS, 0);
	txd_8bit(0x01); //CRF2寄存�?2
	for (m = 0; m < 4; m++)
		txd_8bit(cfr2[m]);
	PS_GPIO_SetPort(CS, 1);
	for (k = 0; k < 10; k++)
		;

	PS_GPIO_SetPort(CS, 0);
	txd_8bit(0x02); //CRF2寄存�?2
	for (m = 0; m < 4; m++)
		txd_8bit(cfr3[m]);
	PS_GPIO_SetPort(CS, 1);
	for (k = 0; k < 10; k++)
		;

	PS_GPIO_SetPort(UP_DAT, 1);
	for (k = 0; k < 10; k++)
		;
	PS_GPIO_SetPort(UP_DAT, 0);
	usleep(1000);

}
//=====================================================================

//======================ad9910发送profile0控制字程===================================
void Txprodile0(void)
{
	uchar m;

	PS_GPIO_SetPort(CS, 0);
	txd_8bit(0x0e); //閸欐垿锟戒垢rofile0閹貉冨煑鐎涙婀撮崸锟�
	for (m = 0; m < 8; m++)
		txd_8bit(profile11[m]);
	PS_GPIO_SetPort(CS, 1);
	// for(k=0;k<10;k++);

	PS_GPIO_SetPort(UP_DAT, 1);
	// for(k=0;k<10;k++);
	PS_GPIO_SetPort(UP_DAT, 0);
	// Delay_ms(1);
}
//=====================================================================
//============================计算频偏字、频率字和发送程�???======================
void Freq_convert(ulong Freq)
{
	ulong Temp;
	Temp = (ulong)Freq * 4.294967296; //鐏忓棜绶崗銉╊暥閻滃洤娲滅�涙劕鍨庢稉鍝勬磽娑擃亜鐡ч懞?  4.294967296=(2^32)/1000000000
	profile11[7] = (uchar)Temp;
	profile11[6] = (uchar)(Temp >> 8);
	profile11[5] = (uchar)(Temp >> 16);
	profile11[4] = (uchar)(Temp >> 24);
	Txprodile0();
}

//======================鐠侊紕鐣诲锝呴浮濞夈垹绠欓�????(Vpp)閸滃苯褰傞柅浣衡柤鎼�????==============================

void Amp_convert(uint Amp)
{
	ulong Temp;
	Temp = (ulong)Amp * 28.4829; //鐏忓棜绶崗銉ョ畽鎼达箑娲滅�涙劕鍨庢稉杞拌⒈娑擃亜鐡ч懞?  25.20615385=(2^14)/650
	if (Temp > 0x3fff)
		Temp = 0x3fff;
	Temp &= 0x3fff;
	profile11[1] = (uchar)Temp;
	profile11[0] = (uchar)(Temp >> 8);
	Txprodile0();
}

//======================ad9910閸欐垿锟戒笍RG閸欏倹鏆熺粙瀣�???==================================
void Txdrg(void)
{
	uchar m,k;

	PS_GPIO_SetPort(CS, 0);
	txd_8bit(0x0b);                                     //閸欐垿锟戒焦鏆熺�涙鏋╅崸锟犳閸掕泛婀撮崸锟�0x0b
	for (m=0;m<8;m++)
		txd_8bit(drgparameter[m]); 
	PS_GPIO_SetPort(CS, 1);
	for(k=0;k<10;k++);
	
	PS_GPIO_SetPort(CS, 0);
	txd_8bit(0x0c);                                     //閸欐垿锟戒焦鏆熺�涙鏋╅崸鈩冾劄闂�鍨勾閸э拷0x0c
	for (m=8;m<16;m++)
		txd_8bit(drgparameter[m]); 
	PS_GPIO_SetPort(CS, 1);
	for(k=0;k<10;k++);
	
	PS_GPIO_SetPort(CS, 0);
	txd_8bit(0x0d);                                     //閸欐垿锟戒焦鏆熺�涙鏋╅崸锟狅拷鐔哄芳閸︽澘�5�?7�???0x0d
	for (m=16;m<20;m++)
		txd_8bit(drgparameter[m]); 
	PS_GPIO_SetPort(CS, 1);
	for(k=0;k<10;k++);
	
	PS_GPIO_SetPort(UP_DAT, 1);
	for(k=0;k<10;k++);
	PS_GPIO_SetPort(UP_DAT, 0);
	usleep(1000);
}         

//=====================閹殿偊顣跺▔銏犲棘閺佹媽顔曠純顔兼嫲閸欐垿锟戒胶鈻兼�????===================================
void SweepFre(ulong SweepMinFre, ulong SweepMaxFre, ulong SweepStepFre, ulong SweepTime)
{
	ulong Temp1, Temp2, ITemp3, DTemp3, ITemp4, DTemp4;
	Temp1 = (ulong)SweepMinFre*4.294967296;
	if(SweepMaxFre > 400000000)
		SweepMaxFre = 400000000;
	Temp2 = (ulong)SweepMaxFre*4.294967296;
	if(SweepStepFre > 400000000)
		SweepStepFre = 400000000;
	ITemp3 = (ulong)SweepStepFre*4.294967296;
	DTemp3 = ITemp3;
	ITemp4 = (ulong)SweepTime/4;                                    //1GHz/4, 閸楁洑缍呴敍姝痵
	if(ITemp4 > 0xffff)
		ITemp4 = 0xffff;
	DTemp4 = ITemp4;
	
	//閹殿偊顣舵稉濠佺瑓闂�????
	drgparameter[7]=(uchar)Temp1;
	drgparameter[6]=(uchar)(Temp1>>8);
	drgparameter[5]=(uchar)(Temp1>>16);
	drgparameter[4]=(uchar)(Temp1>>24);
	drgparameter[3]=(uchar)Temp2;
	drgparameter[2]=(uchar)(Temp2>>8);
	drgparameter[1]=(uchar)(Temp2>>16);
	drgparameter[0]=(uchar)(Temp2>>24);
	//妫版垹宸煎銉ㄧ箻閿涘牆宕熸担宥忕窗Hz閿�?
	drgparameter[15]=(uchar)ITemp3;
	drgparameter[14]=(uchar)(ITemp3>>8);
	drgparameter[13]=(uchar)(ITemp3>>16);
	drgparameter[12]=(uchar)(ITemp3>>24);
	drgparameter[11]=(uchar)DTemp3;
	drgparameter[10]=(uchar)(DTemp3>>8);
	drgparameter[9]=(uchar)(DTemp3>>16);
	drgparameter[8]=(uchar)(DTemp3>>24);
	//濮濄儴绻橀弮鍫曟？闂傛挳娈ч敍鍫濆礋娴ｅ稄绱皍s閿�?
	drgparameter[19]=(uchar)ITemp4;
	drgparameter[18]=(uchar)(ITemp4>>8);
	drgparameter[17]=(uchar)DTemp4;
	drgparameter[16]=(uchar)(DTemp4>>8);
	//閸欐垿锟戒笍RG閸欏倹鏆�???
	Txdrg();
	cfr1[0] = 0x00; //RAM 婢惰精鍏�???
	cfr2[1] = 0x0e; //DRG 娴ｈ儻鍏�???
	Txcfr(); //閸欐垿锟戒恭frx閹貉冨煑鐎�?
}

//==========================閸欐垿锟戒购amprofile0閹貉冨煑鐎�?=============================
void Txramprofile(void)
{
        uchar m,k;

        PS_GPIO_SetPort(CS, 0);
        txd_8bit(0x0e);                            //閸欐垿锟戒购amprofile0閹貉冨煑鐎涙婀撮崸锟�
        for (m=0;m<8;m++)
                txd_8bit(ramprofile0[m]); 
        PS_GPIO_SetPort(CS, 1);
        for(k=0;k<10;k++);

        PS_GPIO_SetPort(UP_DAT, 1);
        for(k=0;k<10;k++);
        PS_GPIO_SetPort(UP_DAT, 0);
        usleep(1000);
} 
	
//=======================閸欐垿锟戒焦鏌熷▔锟斤拷渚�鏁鎸庡皾濞夈垹鑸扮粙瀣�???=============================
void Txramdata(int wave_num)
{
        
	if(wave_num==1)
	{			
		uint m,k;
        PS_GPIO_SetPort(CS, 0);
        txd_8bit(0x16);                                    //閸欐垿锟戒购am閹貉冨煑鐎涙婀撮崸锟�
        for (m=0; m<4096; m++)
						txd_8bit(ramdata_Square[m]); 
        PS_GPIO_SetPort(CS, 1);
        for(k=0;k<10;k++);
        PS_GPIO_SetPort(UP_DAT, 1);
        for(k=0;k<10;k++);
        PS_GPIO_SetPort(UP_DAT, 0);
        usleep(1000);
	}
	else
	{
		uint m,k;
        PS_GPIO_SetPort(CS, 0);
        txd_8bit(0x16);                                   //閸欐垿锟戒购am閹貉冨煑鐎涙婀撮崸锟�
        for(m=0; m<4096; m++)
						txd_8bit(ramdata_Sawtooth[m]); 
        PS_GPIO_SetPort(CS, 1);
        for(k=0;k<10;k++);
        PS_GPIO_SetPort(UP_DAT, 1);
        for(k=0;k<10;k++);
        PS_GPIO_SetPort(UP_DAT, 0);
        usleep(1000);
	}
	
}   

//========================娴溠呮晸閺傝灏濋惃鍕柤鎼�????======================================
void Square_wave(uint Sample_interval)
{
        ulong Temp;

	      Temp = ((1000000000/(unsigned long int)(Sample_interval)/64/4));        //1GHz/4, 闁插洦鐗遍梻鎾閼煎啫娲块�????4*(1~65536)ns
        if(Temp > 0xffff)
                Temp = 0xffff;
        ramprofile0[7] = 0x24;
        ramprofile0[6] = 0x00;
        ramprofile0[5] = 0x00;
        ramprofile0[4] = 0xc0;
        ramprofile0[3] = 0x0f;
        ramprofile0[2] = (uchar)Temp;
        ramprofile0[1] = (uchar)(Temp>>8);
        ramprofile0[0] = 0x00;
        Txramprofile();
				Txramdata(1); 
        cfr1[0] = 0xc0;                                    //RAM 娴ｈ儻鍏橀敍灞界畽鎼达附甯堕崚?
	      cfr2[1] = 0x00;                                              //DRG 婢惰精鍏�???
	      Txcfr();                                               //閸欐垿锟戒恭frx閹貉冨煑鐎�?
}

//========================娴溠呮晸闁款垶濞囧▔銏㈡畱缁嬪绨�=====================================
void Sawtooth_wave(uint Sample_interval)
{
        ulong Temp;

	      Temp = ((1000000000/(unsigned long int)(Sample_interval)/64/4));         //1GHz/4, 闁插洦鐗遍梻鎾閼煎啫娲块�????4*(1~65536)ns
        if(Temp > 0xffff)
                Temp = 0xffff;
        ramprofile0[7] = 0x24;
        ramprofile0[6] = 0x00;
        ramprofile0[5] = 0x00;
        ramprofile0[4] = 0xc0;
        ramprofile0[3] = 0x0f;
        ramprofile0[2] = (uchar)Temp;
        ramprofile0[1] = (uchar)(Temp>>8);
        ramprofile0[0] = 0x00;
        Txramprofile();
				Txramdata(0); 
        cfr1[0] = 0xc0;                                    //RAM 娴ｈ儻鍏橀敍灞界畽鎼达附甯堕崚?
	      cfr2[1] = 0x00;                                              //DRG 婢惰精鍏�???
				Txcfr();                                               //閸欐垿锟戒恭frx閹貉冨煑鐎�?
}

void AD9910_Profile_Set(int profile){
	switch(profile){
		case 0:
			PS_GPIO_SetPort(PROFILE2, IO_RESET);
			PS_GPIO_SetPort(PROFILE1, IO_RESET);
			PS_GPIO_SetPort(PROFILE0, IO_RESET);
			break;
		case 1:
			PS_GPIO_SetPort(PROFILE2, IO_RESET);
			PS_GPIO_SetPort(PROFILE1, IO_RESET);
			PS_GPIO_SetPort(PROFILE0, IO_SET);
			break;
		case 2:
			PS_GPIO_SetPort(PROFILE2, IO_RESET);
			PS_GPIO_SetPort(PROFILE1, IO_SET);
			PS_GPIO_SetPort(PROFILE0, IO_RESET);
			break;
		case 3:
			PS_GPIO_SetPort(PROFILE2, IO_RESET);
			PS_GPIO_SetPort(PROFILE1, IO_SET);
			PS_GPIO_SetPort(PROFILE0, IO_SET);
			break;
		case 4:
			PS_GPIO_SetPort(PROFILE2, IO_SET);
			PS_GPIO_SetPort(PROFILE1, IO_RESET);
			PS_GPIO_SetPort(PROFILE0, IO_RESET);
			break;
		case 5:
			PS_GPIO_SetPort(PROFILE2, IO_SET);
			PS_GPIO_SetPort(PROFILE1, IO_RESET);
			PS_GPIO_SetPort(PROFILE0, IO_SET);
			break;
		case 6:
			PS_GPIO_SetPort(PROFILE2, IO_SET);
			PS_GPIO_SetPort(PROFILE1, IO_SET);
			PS_GPIO_SetPort(PROFILE0, IO_RESET);
			break;
		default: //profile 7
			PS_GPIO_SetPort(PROFILE2, IO_SET);
			PS_GPIO_SetPort(PROFILE1, IO_SET);
			PS_GPIO_SetPort(PROFILE0, IO_SET);
			break;
	}
}

